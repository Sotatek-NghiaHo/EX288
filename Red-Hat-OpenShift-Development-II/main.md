# Chapter 1.  Red Hat OpenShift Container Platform for Developers


![alt text](pic/1.png)
Control Plane

Kubernetes services
- etcd: the distributed key-value store, which Kubernetes uses to store configuration and state information about the containers and other resources inside the cluster.
- kube-apiserver: validates and configures cluster objects and provides the access point to the shared state of the cluster.
- kube-controller-manager: monitors etcd for changes and uses the Kubernetes API to apply changes to the cluster.
- kube-scheduler: selects the nodes where a workload must run.

## Red Hat OpenShift Concepts and Terminology

### Kubernetes Concepts

**Pods**  
A Pod is a collection of containers that share the same storage and network. Pods share the context by using Linux namespaces, cgroups, and other isolation technologies.

Each container in a pod usually contains applications that are more or less logically coupled.

**ReplicaSet**  
The ReplicaSet object indicates the number of pods that are available to attend a request. This object also ties all the pods replicas together so you can operate on them at the same time.

**Deployments**  
A Deployment contains the desired state of an application's pods and uses a ReplicaSet to achieve this desired state. Some changes in the application's state can be: creating pods, declaring a new state of pods, changing the number of pods, or rolling back to a previous Deployment revision.

**Service**  
A Kubernetes Service exposes a set of pods over a network. This abstraction allows internal or external clients of the application running on said pods to connect to them regardless of the actual state of the replicas or varying network IPs.

**Ingress**  
An Ingress exposes services inside the cluster to outside clients by using HTTP or HTTPS. A service ingress can also provide external URLs, load balancing, name-based virtual hosting, or SSL/TLS termination.

**Namespace**  
A Namespace can enable you to isolate resources, encapsulate objects under a unique name, and provide resource quotas.

**Custom Resource**  
Custom Resource (CR) allows extending the Kubernetes API. Custom resources represent entities other than the default ones in Kubernetes. Additionally, Custom resources interact with other cluster objects, regardless of whether those other objects are default or custom.

**Operator**  
An Operator is a custom Kubernetes controller that uses custom resources to deploy and manage applications. It takes high-level user configuration and acts to make the cluster match the desired state.

**Service Account**    
A Service Account is a special kind of account that does not correspond to an actual user, but it is used internally by cluster tools. It is useful for pods to connect to objects in the cluster, such as CI/CD pipelines, secrets, or external resources (outside of the namespace or the cluster).

**Storage Class**   
A Storage Class is a name that identifies a particular kind of storage defined by the cluster administrator. A storage class also defines its characteristics, such as backup policies, service level quality, or any other specification the administrator might choose.

**Persistent Volume**  
A Persistent Volume (PV), is a persistence storage unit offered by the cluster, independent of cluster nodes. This object holds information regarding the size, type, or ability to share storage.

**Persistent Volume Claim**  
Users claim the storage that a PV offers by using a Persistent Volume Claim (PVC). A PVC is a request to access a specific kind of storage of the required size. After acquiring the PVC, the storage is attached to the pods claiming it.

---
# Chapter 2.  Deploying Simple Applications

![alt text](pic/2.png)

![alt text](pic/3.png)

Deploying Applications by Using the Red Hat OpenShift Web Console
- Deploy an application by using a Git repository.
- Deploy an application by using an image from a container registry.

![alt text](pic/5.png)

![alt text](pic/6.png)


## Deploying Applications by Using the oc and odo CLIs



**Deploying Applications with the OpenShift CLI**   
For complex applications, you can use the oc apply command with the -f option. You provide a manifest file that defines the Kubernetes resources for your application.
```
[user@host ~]$ oc apply -f my-manifest.yaml
```
Deploying Applications with oc new-app

![alt text](pic/4.png)

To get a complete list of options and to see a list of examples, run the `oc new-app -h` command.

Example

![alt text](pic/8.png)

![alt text](pic/9.png)

You can delete resources that the oc new-app command creates by using a single oc delete command with the --selector option and the app label. The following command deletes the resources created by the previous oc new-app command:
```
[user@host ~]$ oc delete all --selector app=hello
```

Use the `-o` option to inspect resource definitions without creating resources.
```
[user@host ~]$ oc new-app \
-o yaml registry.example.com/mycontainerimage
apiVersion: v1
items:
- apiVersion: image.openshift.io/v1
  kind: ImageStream
  ...output omitted...
- apiVersion: build.openshift.io/v1
  kind: BuildConfig
  ...output omitted...
- apiVersion: apps/v1
  kind: Deployment
  ...output omitted...
- apiVersion: v1
  kind: Service
  ...output omitted...
kind: List
metadata: {}
```
**Exposing Applications Outside the Cluster.**  
Service resources are only accessible from within the cluster. To provide external access to your application, you can use the oc expose command.

The `oc expose` command creates a Route resource, a type of OpenShift-specific resource. This resource defines the port and protocol for access outside the cluster.

Syntax
```
oc expose [RESOURCE/NAME] [options]
```
Trong ƒë√≥:

- RESOURCE/NAME: lo·∫°i resource v√† t√™n (th∆∞·ªùng l√† service/<service-name> ho·∫∑c deployment/<deploy-name>).
- [options]: c√°c t√πy ch·ªçn ƒë·ªÉ ƒë·ªãnh nghƒ©a route ho·∫∑c service.


M·ªôt s·ªë option quan tr·ªçng

- `--name=<string>`
‚Üí ƒê·∫∑t t√™n cho resource m·ªõi ƒë∆∞·ª£c t·∫°o (v√≠ d·ª•: route).

- `--port=<port-name|number>`
‚Üí Ch·ªâ ƒë·ªãnh c·ªïng t·ª´ Service m√† Route s·∫Ω expose (n·∫øu Service c√≥ nhi·ªÅu port).

- `--target-port=<number>`
‚Üí Ch·ªâ ƒë·ªãnh ch√≠nh x√°c c·ªïng ƒë√≠ch tr√™n Pod container.

- `--hostname=<string>`
‚Üí ƒê·∫∑t hostname (FQDN) cho Route. N·∫øu kh√¥ng c√≥, OpenShift s·∫Ω generate.

- `--path=<string>`
‚Üí G·∫Øn path cho Route (v√≠ d·ª• /api).

- `--type=<string>`
‚Üí Lo·∫°i service mu·ªën expose (ClusterIP, NodePort, LoadBalancer).

- `--generator=<string>`
‚Üí Ki·ªÉu resource generator. M·∫∑c ƒë·ªãnh khi expose Service l√† route/v1

C√∫ ph√°p ƒë·∫ßy ƒë·ªß nh·∫•t (hay d√πng):
```
oc expose service <service-name> \
  --name=<route-name> \
  --port=<service-port> \
  --hostname=<custom-host> \
  --path=<url-path>
```
üîπ `--hostname=<custom-host>`

- D√πng khi b·∫°n mu·ªën Route c√≥ hostname c·ª• th·ªÉ thay v√¨ hostname ng·∫´u nhi√™n OpenShift generate.
- Tr∆∞·ªùng h·ª£p d√πng:
  - B·∫°n mu·ªën public domain d·ªÖ nh·ªõ, v√≠ d·ª•:
```
oc expose service myservice --hostname=weather.apps.ocp.example.com
```
- Khi b·∫°n ƒë√£ c√≥ DNS record tr·ªè v·ªÅ OpenShift router (Ingress).
- Trong m√¥i tr∆∞·ªùng production, hostname th∆∞·ªùng ƒë∆∞·ª£c quy ƒë·ªãnh tr∆∞·ªõc (VD: api.company.com, shop.company.com).

üëâ N·∫øu kh√¥ng set, OpenShift s·∫Ω t·ª± t·∫°o t√™n d·∫°ng:
```
<route-name>-<project>.apps.<cluster-domain>
```
üîπ`--path=<url-path>`
- D√πng ƒë·ªÉ th√™m context path cho route.
- Tr∆∞·ªùng h·ª£p d√πng:
  - Khi b·∫°n mu·ªën nhi·ªÅu ·ª©ng d·ª•ng share chung 1 hostname, nh∆∞ng ph√¢n bi·ªát b·∫±ng path.
V√≠ d·ª•:
```
oc expose service backend --hostname=api.apps.ocp.example.com --path=/backend
oc expose service frontend --hostname=api.apps.ocp.example.com --path=/frontend
```
- Khi ·ª©ng d·ª•ng c·ªßa b·∫°n l·∫Øng nghe tr√™n root /, nh∆∞ng b·∫°n ch·ªâ mu·ªën expose d∆∞·ªõi m·ªôt nh√°nh /app1 ch·∫≥ng h·∫°n.

üëâ N·∫øu kh√¥ng set, m·∫∑c ƒë·ªãnh path l√† `/` (root).

- `--hostname` ‚Üí d√πng khi b·∫°n mu·ªën route c√≥ domain c·ª• th·ªÉ, nh·∫•t l√† trong production (g·∫Øn DNS chu·∫©n).

- `--path` ‚Üí d√πng khi mu·ªën ch·∫°y nhi·ªÅu service/app d∆∞·ªõi c√πng 1 domain nh∆∞ng ph√¢n bi·ªát b·∫±ng ƒë∆∞·ªùng d·∫´n.


OpenShift ch·ªçn port n√†o ƒë·ªÉ expose khi dung `oc expose` command ? 
- oc expose service ... m·∫∑c ƒë·ªãnh l·∫•y port t·ª´ Service.
- N·∫øu Service c√≥ 1 port ‚Üí Route d√πng port ƒë√≥.
- N·∫øu Service c√≥ nhi·ªÅu port ‚Üí b·∫°n ph·∫£i ch·ªâ ƒë·ªãnh --port.

*C√°ch ki·ªÉm tra port service*
```
oc get service openshift-dev-deploy-cli-weather -o yaml
---
ports:
- name: 8080-tcp
  port: 8080
  targetPort: 8080

```
Service c√≥ 8080 v√† 8443 ‚Üí ph·∫£i ch·ªâ ƒë·ªãnh:
```
oc expose service myservice --port=8080
```

**Inner loop vs Outer loop**

![alt text](pic/7.png)

1. Inner loop vs Outer loop

- Inner loop: v√≤ng l·∫∑p ng·∫Øn c·ªßa dev ‚Üí code ‚Üí build ‚Üí test nhanh ‚Üí debug ‚Üí l·∫∑p l·∫°i.
  - ƒê√¢y l√† ph·∫ßn m√† odo h·ªó tr·ª£ m·∫°nh nh·∫•t (deploy code nhanh l√™n cluster ƒë·ªÉ test).

- Outer loop: v√≤ng l·∫∑p d√†i h∆°n ‚Üí build artifact ch√≠nh th·ª©c ‚Üí ch·∫°y integration test, security test ‚Üí deploy v√†o m√¥i tr∆∞·ªùng prod/staging.
  - odo c≈©ng c√≥ th·ªÉ ƒë·ªãnh nghƒ©a ƒë∆∞·ª£c qua devfile.yaml.

2. Devfile (devfile.yaml)

L√† file trung t√¢m, m√¥ t·∫£:
- Components: container images, manifests, volume‚Ä¶
- Commands: c√°c b∆∞·ªõc c·∫ßn ch·∫°y (build, run, test, debug, deploy).
- Command groups: gom l·ªánh theo nh√≥m (`build, run, test, debug, deploy`).
Nh·ªù devfile, odo bi·∫øt ph·∫£i l√†m g√¨ khi b·∫°n g√µ:
- odo build
- odo run
- odo test
- odo debug
- odo deploy

Note: 
- N·∫øu mu·ªën odo <kind> ch·∫°y m·∫∑c ƒë·ªãnh, b·∫°n ph·∫£i b·∫≠t isDefault: true.
- N·∫øu c√≥ nhi·ªÅu command c√πng kind th√¨ ch·ªâ 1 ƒë∆∞·ª£c default, c√≤n l·∫°i ph·∫£i g·ªçi b·∫±ng --command <id>.

3. `odo init`
- T·∫°o file devfile.yaml ban ƒë·∫ßu.
- odo s·∫Ω c·ªë g·∫Øng ƒëo√°n runtime t·ª´ source code (v√≠ d·ª• th·∫•y package.json ‚Üí Node.js, th·∫•y requirements.txt ‚Üí Python).
- N·∫øu b·∫°n kh√¥ng truy·ªÅn options, n√≥ s·∫Ω m·ªü interactive mode ƒë·ªÉ b·∫°n ch·ªçn.
- N√≥ c·∫ßn k·∫øt n·ªëi t·ªõi devfile registry (m·∫∑c ƒë·ªãnh: https://registry.devfile.io
) ƒë·ªÉ l·∫•y template ph√π h·ª£p.

> Sau khi c√≥ devfile.yaml, b·∫°n c√≥ th·ªÉ s·ª≠a ƒë·ªÉ ph√π h·ª£p v·ªõi project.

4. L·ªánh `odo create project`
```
odo create project PROJECT_NAME
```
- T·∫°o m·ªôt OpenShift Project (namespace) m·ªõi tr·ª±c ti·∫øp t·ª´ odo.
- T∆∞∆°ng ƒë∆∞∆°ng v·ªõi l·ªánh: `oc new-project PROJECT_NAME`

The following devfile provides a simplified example for outer loop development with odo. The devfile adheres to the following requirements:

- The `Dockerfile` must exist in the same directory as the `devfile.yaml`.

- The `deploy.yaml` contains the Kubernetes resources for the application.

- The parent devfile must exist.

- The odo command must be able to access Podman and an authenticated image registry.

![alt text](pic/10.png)

Example deploy.yaml
```bash
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nodejs-app
  labels:
    app: nodejs-app
spec:
...
---
apiVersion: v1
kind: Service
metadata:
  name: nodejs-app
  labels:
    app: nodejs-app
spec:
  selector:

...
---
apiVersion: route.openshift.io/v1
kind: Route
metadata:
  name: nodejs-app
spec:
  to:

```
**Container Image Renaming with odo**  
*V·∫•n ƒë·ªÅ*
- Trong devfile.yaml b·∫°n c√≥ th·ªÉ ƒë·ªãnh nghƒ©a image component ƒë·ªÉ build/push image.
- N·∫øu b·∫°n vi·∫øt th·∫≥ng image name ƒë·∫ßy ƒë·ªß (v√≠ d·ª•: quay.io/myuser/nodejs-app:1.0), th√¨ devfile b·ªã g·∫Øn ch·∫∑t v·ªõi registry ƒë√≥ ‚Üí kh√≥ chia s·∫ª cho ng∆∞·ªùi kh√°c.
- V√¨ v·∫≠y, odo h·ªó tr·ª£ image renaming ƒë·ªÉ l√†m devfile portable (d√πng l·∫°i ·ªü nhi·ªÅu cluster/registry kh√°c nhau).

*C√°ch ho·∫°t ƒë·ªông*

1. Khai b√°o `ImageRegistry`
B·∫°n set registry m·∫∑c ƒë·ªãnh ƒë·ªÉ odo push image:
```
odo preference set ImageRegistry quay.io/myuser

# syntax
[user@host ~]$ odo preference set ImageRegistry REGISTRY_URL/NAMESPACE
```
‚Üí Sau ƒë√≥ m·ªçi image s·∫Ω ƒë∆∞·ª£c push v·ªÅ quay.io/myuser/....

2. D√πng imageName t∆∞∆°ng ƒë·ªëi trong devfile  
Trong `devfile.yaml`:
```
components:
  - name: relative-image
    image:
      imageName: "my-relative-image"   # ch·ªâ c√≥ t√™n, kh√¥ng c√≥ registry
```

üëâ ƒê√¢y g·ªçi l√† relative image name.

3. Khi build/push, odo s·∫Ω t·ª± ƒë·ªïi t√™n image th√†nh:
```
<ImageRegistry>/<DevfileName>-<ImageName>:<UniqueId>
```
- ImageRegistry: gi√° tr·ªã b·∫°n set (quay.io/myuser)
- DevfileName: t√™n devfile (v√≠ d·ª• nodejs-app)
- ImageName: ph·∫ßn b·∫°n ƒë·ªãnh nghƒ©a (my-relative-image)
- UniqueId: gi√° tr·ªã random ƒë·ªÉ tr√°nh tr√πng

üìù V√≠ d·ª• c·ª• th·ªÉ

Devfile nodejs-app c√≥:
```
components:
  - name: relative-image
    image:
      imageName: "my-relative-image"
```

B·∫°n set:
```
odo preference set ImageRegistry quay.io/nghia
```

Khi odo deploy, image th·ª±c t·∫ø ƒë∆∞·ª£c push s·∫Ω th√†nh:
```
quay.io/nghia/nodejs-app-my-relative-image:abc123
```
‚úÖ L·ª£i √≠ch

- Devfile kh√¥ng b·ªã hard-code registry ‚Üí portable, d·ªÖ chia s·∫ª cho team kh√°c.
- odo t·ª± ƒë·ªông ƒë·ªïi t√™n v√† push image ƒë√∫ng registry b·∫°n ch·ªâ ƒë·ªãnh.
- B·∫°n c√≥ th·ªÉ ki·ªÉm tra:
  - Trong registry (quay.io/nghia/...)
  - Ho·∫∑c trong resource YAML m√† odo apply l√™n cluster.

**Syntax h·ªØu √≠ch c·ªßa oc new-app**
```bash
oc new-app <image>                  # T·∫°o t·ª´ image
oc new-app --image=<image>
oc new-app <image>~<git-repo>       # S2I build t·ª´ source code
oc new-app -f template.yaml         # D√πng template file
oc new-app --name=myapp             # ƒê·∫∑t t√™n app
oc new-app <image> -e VAR=VALUE     # Th√™m bi·∫øn m√¥i tr∆∞·ªùng
oc new-app <image> --as-deployment-config  # D√πng DeploymentConfig thay v√¨ Deployment
```

**Image m√† oc new-app d√πng t·ª´ ƒë√¢u ra?**

![alt text](pic/11.png)

üîπ 2. V·∫≠y podman build li√™n quan g√¨?
- N·∫øu b·∫°n t·ª± build m·ªôt image b·∫±ng podman build tr√™n m√°y local th√¨ image ƒë√≥ ch·ªâ n·∫±m trong local host.
- ƒê·ªÉ OpenShift d√πng ƒë∆∞·ª£c, b·∫°n ph·∫£i push image ƒë√≥ l√™n m·ªôt registry (v√≠ d·ª•: quay.io, docker.io, ho·∫∑c internal OpenShift registry image-registry.openshift-image-registry.svc:5000).

Sau ƒë√≥ b·∫°n m·ªõi d√πng:
```
oc new-app <registry>/<namespace>/<image>:<tag>
```

M·∫∑c ƒë·ªãnh `oc new-app` ch·ªâ gi√∫p b·∫°n deploy nhanh ƒë·ªÉ test, c√≤n n·∫øu mu·ªën t√πy ch·ªânh chi ti·∫øt th√¨ c√≥ v√†i c√°ch:

![alt text](pic/12.png)

**T√πy ch·ªânh**

- T√πy ch·ªânh ngay t·ª´ l·ªánh `oc new-app`
```bash
# Example
oc scale deployment myapp --replicas=3
oc expose deployment myapp --port=8080 --target-port=8080
```
- Ch·ªânh sau khi resource ƒë∆∞·ª£c t·∫°o
```bash
# Xu·∫•t YAML ra file ƒë·ªÉ ch·ªânh:
oc get deployment myapp -o yaml > myapp-deploy.yaml

# -> S·ª≠a YAML (replicas, resource limits, volume, env, liveness probe‚Ä¶)

# Apply l·∫°i:
oc apply -f myapp-deploy.yaml
```
3. D√πng workflow hi·ªán ƒë·∫°i (recommended)  
Thay v√¨ `oc new-app` (quick & simple), b·∫°n c√≥ th·ªÉ:
- Vi·∫øt s·∫µn Deployment + Service YAML ‚Üí `oc apply -f`.
- Ho·∫∑c d√πng odo v·ªõi devfile.yaml n·∫øu ph√°t tri·ªÉn app.
- Ho·∫∑c d√πng BuildConfig + ImageStream n·∫øu mu·ªën workflow CI/CD theo ki·ªÉu OpenShift truy·ªÅn th·ªëng.

---
# Chapter 3.  Building and Publishing Container Images

Red Hat Universal Base Images
When defining custom container images, Red Hat recommends the use of Red Hat Universal Base Images (UBI) as the base container images for your applications. UBI images are certified, tested, and regularly maintained images that Red Hat provides at no cost.

UBI images also provide the following major benefits:

**Universal**  
UBI images are designed to be used as the base images for developing container-based applications.

**Robust**  
UBI images are based on Red Hat Enterprise Linux (RHEL). This brings characteristics such as stability and vulnerability management to your base container images.

**Standard**  
UBI images are compliant with the Open Container Initiative (OCI).

**Extensible**  
UBI images provide package managers and other tools for installing additional software.

**OpenShift-optimized**  
UBI images are tailored to work well on Red Hat OpenShift.

**Redistributable**  
The UBI End-User Licensing Agreement (EULA) permits free distribution of the applications that you build on top of UBI images.

Red Hat provides four types of UBI images, designed to cover most use cases.

Image type	|Image name	|Uses
---|---|---
Standard	|ubi|	For most applications and use cases
Init	|ubi-init|	For containers that run multiple systemd services
Minimal	|ubi-minimal	|Smaller image for applications that manage their own dependencies and depend on fewer OS components
Micro	|ubi-micro	|Smallest image for optimized memory-footprint use cases; for applications that use almost no OS components

Runtime UBI Images For Developers
Red Hat provides UBI images for the following runtime languages:
- OpenJDK
- Node.js
- Python
- PHP
- .NET
- Go
- Ruby
 
Optimize Containerfiles for OpenShift  
Format
```
registry.access.redhat.com/NAMESPACE/NAME[:TAG]
```
Example 
```
FROM registry.access.redhat.com/ubi10/nodejs-22-minimal:10.0
```
**Ensure That Your Containers Handle Interruption Signals**

üîπ 1. C∆° ch·∫ø shutdown m·∫∑c ƒë·ªãnh

Khi b·∫°n x√≥a Pod ho·∫∑c rollout Deployment m·ªõi, OpenShift s·∫Ω:
- G·ª≠i t√≠n hi·ªáu SIGTERM ƒë·∫øn process PID 1 trong container.
- Container/app c·ªßa b·∫°n c√≥ tr√°ch nhi·ªám ng·∫Øt k·∫øt n·ªëi, ƒë√≥ng resource, l∆∞u data‚Ä¶.
- N·∫øu trong th·ªùi gian terminationGracePeriodSeconds (m·∫∑c ƒë·ªãnh 30s) app kh√¥ng t·∫Øt ‚Üí OpenShift g·ª≠i SIGKILL (kill ngay l·∫≠p t·ª©c).

üëâ Do ƒë√≥, ·ª©ng d·ª•ng ph·∫£i bi·∫øt c√°ch handle SIGTERM ƒë·ªÉ shutdown ‚Äú√™m ƒë·∫πp‚Äù (graceful shutdown).

üîπ 2. Tr∆∞·ªùng h·ª£p ·ª©ng d·ª•ng kh√¥ng handle SIGTERM

V√≠ d·ª•:
- M·ªôt app Java ch·∫°y b·∫±ng java -jar example.jar.
- N·∫øu b·∫°n kh√¥ng trap SIGTERM, khi Pod b·ªã kill ‚Üí Java process s·∫Ω t·∫Øt ngay ‚Üí c√≥ th·ªÉ m·∫•t data, ch∆∞a commit transaction, connection b·ªã c·∫Øt ƒë·ªôt ng·ªôt.

C√°ch x·ª≠ l√Ω:
- Vi·∫øt entrypoint script (nh∆∞ v√≠ d·ª• trong b√†i): trap t√≠n hi·ªáu SIGTERM v√† forward cho app, r·ªìi wait cho app shutdown.
```
trap graceful_shutdown SIGTERM
java -jar example.jar &
java_pid=$!
wait "$java_pid"
```

·ªû ƒë√¢y:

- trap graceful_shutdown SIGTERM: khi nh·∫≠n SIGTERM ‚Üí g·ªçi h√†m graceful_shutdown.

- H√†m n√†y g·ª≠i SIGTERM ƒë·∫øn process Java (kill -SIGTERM $java_pid) v√† ƒë·ª£i n√≥ shutdown.

üîπ 3. Khi app kh√¥ng s·ª≠a code ƒë∆∞·ª£c

N·∫øu ·ª©ng d·ª•ng kh√¥ng c√≥ c∆° ch·∫ø nh·∫≠n SIGTERM (ho·∫∑c b·∫°n kh√¥ng th·ªÉ thay ƒë·ªïi entrypoint), b·∫°n c√≥ th·ªÉ d√πng Pod lifecycle hook:
```
lifecycle:
  preStop:
    httpGet:
      path: /shutdown
      port: 8080
```

- Khi Pod chu·∫©n b·ªã b·ªã x√≥a, kubelet s·∫Ω g·ªçi HTTP GET v√†o /shutdown.

- ·ª®ng d·ª•ng s·∫Ω nh·∫≠n request n√†y v√† th·ª±c hi·ªán cleanup (ƒë√≥ng k·∫øt n·ªëi, flush cache, l∆∞u tr·∫°ng th√°i, v.v).

- Sau ƒë√≥ m·ªõi nh·∫≠n SIGTERM ƒë·ªÉ t·∫Øt h·∫≥n.

üîπ 4. N·∫øu app v·∫´n kh√¥ng t·∫Øt?

- Sau khi h·∫øt th·ªùi gian terminationGracePeriodSeconds, kubelet/OpenShift g·ª≠i SIGKILL ‚Üí process b·ªã kill ngay l·∫≠p t·ª©c.

- L√∫c n√†y kh√¥ng c√≥ c∆° h·ªôi cleanup ‚Üí nguy c∆° m·∫•t d·ªØ li·ªáu ho·∫∑c l·ªói.

‚úÖ T√≥m l·∫°i

- OpenShift/K8s lu√¥n g·ª≠i SIGTERM tr∆∞·ªõc ƒë·ªÉ cho app t·ª± shutdown √™m ƒë·∫πp.

- App n√™n handle SIGTERM (qua entrypoint script).

- N·∫øu kh√¥ng th·ªÉ ‚Üí d√πng preStop hook ƒë·ªÉ app cleanup tr∆∞·ªõc khi b·ªã kill.

- N·∫øu app v·∫´n kh√¥ng shutdown k·ªãp ‚Üí cu·ªëi c√πng b·ªã SIGKILL (force kill).

![alt text](pic/13.png)

**Reduce Image Size**

1. Gi·∫£m s·ªë l∆∞·ª£ng RUN
- K·∫øt h·ª£p nhi·ªÅu l·ªánh th√†nh 1 RUN ƒë·ªÉ gi·∫£m s·ªë layer.

2. Gi·∫£m build context
- D√πng .dockerignore / .containerignore ƒë·ªÉ lo·∫°i b·ªè file/th∆∞ m·ª•c kh√¥ng c·∫ßn thi·∫øt.

3. Multistage build
- Stage ƒë·∫ßu: build app b·∫±ng image ƒë·∫ßy ƒë·ªß (v√≠ d·ª•: ubi9/nodejs-22).
- Stage cu·ªëi: copy artifact sang image minimal/runtime (ubi9/nodejs-22-minimal).
- ‚Üí K·∫øt qu·∫£: image nh·ªè g·ªçn, ch·ªâ ch·ª©a runtime + app.

4. D√πng minimal image

- Node.js: nodejs-22-minimal.
- OpenJDK: ubi9/openjdk-21-runtime.

5. LABEL
- D√πng LABEL ƒë·ªÉ khai b√°o metadata.
- V√≠ d·ª•: LABEL io.openshift.min-cpu 2 ‚Üí UI OpenShift c·∫£nh b√°o c·∫ßn √≠t nh·∫•t 2 CPU.

6. WORKDIR
- Lu√¥n d√πng WORKDIR v·ªõi absolute path thay v√¨ nhi·ªÅu l·∫ßn cd trong RUN.
7. ENV v√† ARG
- D√πng ENV ƒë·ªÉ c·∫•u h√¨nh ƒë∆∞·ªùng d·∫´n, version, PATH‚Ä¶
- D√πng ARG cho bi·∫øn build-time ‚Üí t·∫°o image t√°i s·ª≠ d·ª•ng ƒë∆∞·ª£c.
8. VOLUME
- Khai b√°o r√µ VOLUME ƒë·ªÉ ng∆∞·ªùi d√πng bi·∫øt mount d·ªØ li·ªáu.
- N·∫øu kh√¥ng mount, OpenShift s·∫Ω t·ª± g·∫Øn EmptyDir (ephemeral).

9. EXPOSE
- Ch·ªâ expose port >1024 (kh√¥ng c·∫ßn quy·ªÅn root).
- oc new-app s·∫Ω t·ª± t·∫°o Deployment + Service theo port ƒë∆∞·ª£c EXPOSE.
- Web console c≈©ng nh·∫≠n di·ªán c√°c port n√†y ƒë·ªÉ c·∫•u h√¨nh service.

üëâ T√≥m g·ªçn l·∫°i:
- Multistage + minimal UBI image ‚Üí gi·∫£m size.
- LABEL, ENV, VOLUME, EXPOSE ‚Üí gi√∫p OpenShift hi·ªÉu r√µ image, h·ªó tr·ª£ c·∫•u h√¨nh d·ªÖ d√†ng.
- WORKDIR v√† √≠t RUN ‚Üí l√†m Containerfile g·ªçn, d·ªÖ maintain.

**Build and Push Images with Podman**  
You can use a tool such as Podman to build a container image locally and push the image to a container registry.

> Note
You can also use OpenShift to build your container images. The OpenShift build capabilities, such as Source-to-Image (S2I) and Docker builds, are covered later in this course. OpenShift also provides the OpenShift Builds framework, which is based on the Shipwright project.

Use the podman build command to create a container image from a Containerfile, as the following example shows:
```
[user@host ~]$ podman build CONTEXT_DIR -t IMAGE
```
The preceding command creates a local container image by using the Containerfile or Dockerfile at the CONTEXT_DIR directory. The produced image is called IMAGE. After building the container image locally, push the image to a container registry by using the podman push command.
```
[user@host ~]$ podman push IMAGE
```
> Note
You must be logged in to the registry to push images. You can log in with the podman login command.

After the image is published in the container registry, you can deploy the image by using any of the methods that Red Hat OpenShift provides, such as the web console, or the oc and odo CLIs.

## Guided Exercise: Building Container Images for Red Hat OpenShift


```bash
oc new-app \
--name greetings \
--image=registry.ocp4.example.com:8443/developer/images-ubi-greetings:1.0.0
```
File Containerfile
![alt text](pic/15.png)

3 error khi `oc new-app`  
![alt text](pic/14.png)

**Fix 1**  
Remove the USER instruction from the Containerfile. The file must look as follows:
```
FROM registry.ocp4.example.com:8443/ubi10/nodejs-22-minimal:10.0

ENV PORT=80
EXPOSE ${PORT}

ADD . $HOME

RUN npm ci --omit=dev && rm -rf .npm

CMD npm start
```

**Fix 2**  
Trong Linux (v√† c≈©ng ƒë√∫ng trong container), c√≥ quy t·∫Øc:
- Port < 1024 = privileged ports ‚Üí ch·ªâ process ch·∫°y b·∫±ng root user m·ªõi bind ƒë∆∞·ª£c.
- Port ‚â• 1024 = unprivileged ports ‚Üí b·∫•t k·ª≥ non-root user n√†o c≈©ng bind ƒë∆∞·ª£c.

V√¨ sao l·ªói x·∫£y ra?
- ·ª®ng d·ª•ng c·ªßa b·∫°n c·ªë g·∫Øng l·∫Øng nghe tr√™n c·ªïng 80:
```
Error: listen EACCES: permission denied 0.0.0.0:80
```
- Nh∆∞ng trong OpenShift, container ch·∫°y v·ªõi m·ªôt UID ng·∫´u nhi√™n, kh√¥ng ph·∫£i root.
- Do ƒë√≥, process ƒë√≥ kh√¥ng th·ªÉ m·ªü ƒë∆∞·ª£c c·ªïng 80 ‚Üí b√°o l·ªói EACCES.

**Fix 3**  
Fix the permissions of the /var/cache directory. In the Containerfile, add a RUN instruction that runs as the root user and ensures that the group assigned to the /var/cache directory is the root group (0). Then, it should grant the root group the same permissions as the user that owns this directory. Finally, it should restore 1001 as the user ID that runs the application.
```bash
...omitted...
RUN npm ci --omit=dev && rm -rf .npm

USER root
RUN chgrp -R 0 /var/cache && \
    chmod -R g=u /var/cache
USER 1001

CMD npm start
```
-> rebuild image, run -rm , podman push -> oc new-app -> expose > get url



